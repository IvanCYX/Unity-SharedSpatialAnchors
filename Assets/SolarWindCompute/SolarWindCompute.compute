#pragma kernel CSMain

static const float PI = 3.14159265f;
static const int threadCount = 1024;

uint _ParticleCount;

float _particleCharge;
float _particleMass;
float _earthMagneticFieldMagnitude;
float _earthRadius;
float3 _earthDipole;

float _dt;
float _initialSpeed;

RWStructuredBuffer<float3> _Position;
RWStructuredBuffer<float3> _Velocity;

float InverseLerp(float a, float b, float v) {return (v-a)/(b-a);}
float Remap(float iMin, float iMax, float oMin, float oMax, float v) {float t = InverseLerp(iMin, iMax, v); return lerp(oMin, oMax, t);}

float getR(float3 position) {return length(position);}
float getTheta(float3 position) {return acos(position.z / length(position));}
float getPhi(float3 position) {return sign(position.y) * acos(position.x / length(position.xy));}
float getX(float r, float theta, float phi) {return r * sin(theta) * cos(phi);}
float getY(float r, float theta, float phi) {return r * sin(theta) * sin(phi);}
float getZ(float r, float theta, float phi) {return r * cos(theta);}

float3 calculateEarthMagneticField(float3 position) {
    float r = getR(position);
    float3 rUnit = normalize(position);

    return _earthMagneticFieldMagnitude / pow(r, 3) * (3 * dot(_earthDipole, rUnit) * rUnit - _earthDipole);
} 

/*float3 constantField(float3 position) {
    return float3(0,_earthMagneticFieldMagnitude,0);
} */


float3 calculateVelocityFromMagenticField(float3 velocity, float3 magneticField) {
    return _particleCharge * cross(velocity, magneticField) / _particleMass;
}

[numthreads(threadCount,1,1)]
void CSMain(uint3 id : SV_DispatchThreadID) { 
    if(id.x < _ParticleCount) {
        _Velocity[id.x] += calculateVelocityFromMagenticField(_Velocity[id.x], calculateEarthMagneticField(_Position[id.x])) * _dt;
        _Velocity[id.x] = _initialSpeed * normalize(_Velocity[id.x]);
        _Position[id.x] += _Velocity[id.x] * _dt;
    }
}
