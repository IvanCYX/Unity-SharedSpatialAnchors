#pragma kernel CSMain

static const float PI = 3.14159265f;
static const int threadCount = 1024;

uint _ParticleCount;

float _a;
float _b;
float _c;

float _charge;
float _earthMagneticFieldMagnitude;
float _earthRadius;
float3 _earthDipole;

StructuredBuffer<float3> _Position;
RWStructuredBuffer<float3> _Velocity;

float InverseLerp(float a, float b, float v) {return (v-a)/(b-a);}
float Remap(float iMin, float iMax, float oMin, float oMax, float v) {float t = InverseLerp(iMin, iMax, v); return lerp(oMin, oMax, t);}

float getR(float3 position) {return length(position);}
float getTheta(float3 position) {return acos(position.z / length(position));}
float getPhi(float3 position) {return sign(position.y) * acos(position.x / length(position.xy));}
float getX(float r, float theta, float phi) {return r * sin(theta) * cos(phi);}
float getY(float r, float theta, float phi) {return r * sin(theta) * sin(phi);}
float getZ(float r, float theta, float phi) {return r * cos(theta);}

/*
float3 calculateEarthMagneticField(float3 position) {
    float r = getR(position);
    float theta = getTheta(position);
    float phi = getPhi(position);

    if(r < _earthRadius) {return float3(10000,10000,10000);}

    float radialField = -2 * _earthMagneticFieldMagnitude * pow(_earthRadius / r, 3) * cos(theta);
    float latitudinalField = -_earthMagneticFieldMagnitude * pow(_earthRadius / r, 3) * sin(theta);

    return radialField * normalize(position) + latitudinalField * float3(cos(phi),0,sin(phi));
} */

float3 calculateEarthMagneticField(float3 position) {
    float r = getR(position);
    float theta = getTheta(position);
    float phi = getPhi(position);

    float3 earthDipole = float3(0, 2,0);

    return (pow(_earthRadius / r, 3)) * (3 * dot(_earthDipole, normalize(position)) * normalize(position) - _earthDipole);
} 

float3 calculateVelocityFromMagenticField(float charge, float3 velocity, float3 magneticField) {
    return charge * cross(velocity, magneticField);
}

float3 lorenzAttractor(float3 radialVector) {
    float3 field;

    field.x = _a * (radialVector.y - radialVector.x);
    field.y = radialVector.x * (_b - radialVector.z) - radialVector.y;
    field.z = radialVector.x * radialVector.y - _c * radialVector.z;

    return field;
}

[numthreads(threadCount,1,1)]
void CSMain(uint3 id : SV_DispatchThreadID) { 
    if(id.x < _ParticleCount) {
        //_Field[id.x] = lorenzAttractor(_Position[id.x]);
        _Velocity[id.x] += calculateVelocityFromMagenticField(_charge, _Velocity[id.x], calculateEarthMagneticField(_Position[id.x]));
        //_Velocity[id.x] = calculateEarthMagneticField(_Position[id.x]);
    }
}
